# analise_laboratorial.py (Vers√£o 7.30 - Corre√ß√£o de Legenda Duplicada e Posi√ß√£o na Aba 'Alterados' e Card de Exame)

import tkinter as tk
from tkinter import filedialog, messagebox
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.dates as mdates 
import numpy as np
import random
from matplotlib.figure import Figure 
import datetime
import re 
from matplotlib import gridspec 
try:
    import mplcursors 
except ImportError:
    mplcursors = None 

# Configura√ß√£o global de Matplotlib
plt.style.use('seaborn-v0_8-whitegrid') 

# --- Fun√ß√µes Auxiliares de Convers√£o ---

def _converter_idade_para_anos(idade_str):
    """
    Converte strings de idade (ex: '10d', '6m', '25') para um valor num√©rico em anos (float).
    Usada para processar a coluna 'idade' do CSV.
    """
    if pd.isna(idade_str):
        return np.nan
        
    idade_str = str(idade_str).strip().lower().replace(',', '.')
    
    match = re.match(r'^(\d+(\.\d+)?)\s*(d|m)$', idade_str)
    
    if match:
        valor = float(match.group(1))
        unidade = match.group(3)
        if unidade == 'd':
            return round(valor / 365.25, 4) 
        elif unidade == 'm':
            return round(valor / 12, 2)
    
    try:
        return float(idade_str)
    except ValueError:
        return np.nan
        
def _converter_idade_input_para_anos(idade_str):
    """
    Converte strings de idade de input manual (ex: '10d', '6m', '25') para int/float em ANOS.
    Usada para processar o filtro de Idade.
    """
    if not idade_str:
        return 0.0 
        
    idade_str = str(idade_str).strip().lower().replace(',', '.')
    
    match = re.match(r'^(\d+)\s*d$', idade_str)
    if match: # Idade em dias
        return float(match.group(1)) / 365.25
        
    match = re.match(r'^(\d+)\s*m$', idade_str)
    if match: # Idade em meses
        return float(match.group(1)) / 12.0 

    try:
        # Se for apenas n√∫mero, assume anos.
        return float(idade_str)
    except ValueError:
             raise ValueError(f"Formato de idade inv√°lido: {idade_str}. Use 'anos inteiros', 'Xd' (dias) ou 'Xm' (meses).")
             
def _formatar_idade_para_exibicao(idade):
    """Formata o valor de idade de volta para o formato de exibi√ß√£o (ex: 0.01 -> 5d)."""
    if idade == 0:
        return "0"
    if idade < 1:
        # Se menos de 30 dias, mostra em dias
        if idade * 365.25 < 30:
            return f"{round(idade * 365.25)}d"
        # Se menos de 1 ano, mostra em meses
        else:
             return f"{round(idade * 12)}m"
    return str(int(idade)) 

# --- Classes VRManager e PeriodSelector ---

class VRManager(ttk.Toplevel):
    
    def __init__(self, master, exames_disponiveis, regras_vr):
        super().__init__(master)
        self.master = master
        self.regras_vr = regras_vr.copy() 
        self.exames_disponiveis = exames_disponiveis
        
        self.title("Gerenciar Valores de Refer√™ncia (VRs)")
        self.geometry("800x450")
        self.transient(master) 
        self.grab_set() 
        
        self.setup_layout()

    def setup_layout(self):
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(fill=BOTH, expand=True)

        # ----------------------------------------------------------------------
        # 1. Adicionar Nova Regra de Refer√™ncia
        # ----------------------------------------------------------------------
        frame_adicionar = ttk.LabelFrame(main_frame, text="1. Adicionar Nova Regra de Refer√™ncia", padding=10, bootstyle=PRIMARY)
        frame_adicionar.pack(fill=X, pady=10)

        input_frame = ttk.Frame(frame_adicionar, padding=5)
        input_frame.pack(fill=X, pady=5)
        
        ttk.Label(input_frame, text="Exame").grid(row=0, column=0, padx=5)
        ttk.Label(input_frame, text="Sexo").grid(row=0, column=1, padx=5)
        ttk.Label(input_frame, text="Idade Min (a/d/m)").grid(row=0, column=2, padx=5)
        ttk.Label(input_frame, text="Idade Max (a/d/m)").grid(row=0, column=3, padx=5)
        ttk.Label(input_frame, text="Ref Min").grid(row=0, column=4, padx=5)
        ttk.Label(input_frame, text="Ref Max").grid(row=0, column=5, padx=5)
        ttk.Label(input_frame, text="A√ß√£o").grid(row=0, column=6, padx=5) 

        self.exame_var = tk.StringVar(self)
        self.exame_var.set(self.exames_disponiveis[0] if self.exames_disponiveis else "SEM EXAMES")
        self.sexo_var = tk.StringVar(self)
        self.sexo_var.set("AMBOS")
        self.idade_min_var = tk.StringVar(self, value="0")
        self.idade_max_var = tk.StringVar(self, value="120")
        self.ref_min_var = tk.StringVar(self)
        self.ref_max_var = tk.StringVar(self)

        row_index = 1
        ttk.Combobox(input_frame, textvariable=self.exame_var, values=self.exames_disponiveis, state='readonly', width=12).grid(row=row_index, column=0, padx=5)
        ttk.Combobox(input_frame, textvariable=self.sexo_var, values=["AMBOS", "MASCULINO", "FEMININO"], state='readonly', width=8).grid(row=row_index, column=1, padx=5)
        ttk.Entry(input_frame, textvariable=self.idade_min_var, width=8).grid(row=row_index, column=2, padx=5)
        ttk.Entry(input_frame, textvariable=self.idade_max_var, width=8).grid(row=row_index, column=3, padx=5)
        ttk.Entry(input_frame, textvariable=self.ref_min_var, width=8).grid(row=row_index, column=4, padx=5)
        ttk.Entry(input_frame, textvariable=self.ref_max_var, width=8).grid(row=row_index, column=5, padx=5)
        ttk.Button(input_frame, text="+ Adicionar Regra", command=self.adicionar_regra_manual, bootstyle=SUCCESS).grid(row=row_index, column=6, padx=5)
        
        
        # ----------------------------------------------------------------------
        # 2. Regras Ativas (Tabela)
        # ----------------------------------------------------------------------
        frame_regras = ttk.LabelFrame(main_frame, text="Regras Ativas (Clique em uma regra e use o bot√£o 'Remover')", padding=10, bootstyle=PRIMARY)
        frame_regras.pack(fill=X, pady=10)

        columns = ("Exame", "Sexo", "Idade Min", "Idade Max", "Ref Min", "Ref Max")
        self.tree = ttk.Treeview(frame_regras, columns=columns, show='headings', bootstyle=PRIMARY, height=5)
        
        for col in columns:
            self.tree.heading(col, text=col.replace(" ", "\n"))
            self.tree.column(col, width=80 if "Ref" in col else 100, anchor=CENTER)

        self.tree.pack(fill=X, expand=True)
        self.tree.bind('<<TreeviewSelect>>', self.on_treeview_select)
        
        ttk.Button(main_frame, text="Remover Regra Selecionada", command=self.remover_regra_selecionada, bootstyle=DANGER).pack(fill=X, pady=10)

        
        self.update_treeview()


    def on_treeview_select(self, event):
        pass
            
    def update_treeview(self):
        """Limpa e preenche o Treeview com as regras VR atuais."""
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        for i, r in enumerate(self.regras_vr):
            
            idade_min_display = _formatar_idade_para_exibicao(r['idade_min'])
            idade_max_display = _formatar_idade_para_exibicao(r['idade_max'])

            self.tree.insert('', 'end', text=str(i), values=(
                r['exame'], r['sexo'], idade_min_display, idade_max_display, 
                f"{r['ref_min']:.2f}", f"{r['ref_max']:.2f}"
            ))
        
        
    def remover_regra_selecionada(self):
        """Remove a regra VR selecionada e atualiza os gr√°ficos."""
        item_id = self.tree.focus()
        if not item_id:
            self.master.show_message("Aviso", "Selecione uma regra na tabela para remover.", type="warning")
            return
            
        row_index = int(self.tree.item(item_id, 'text')) 
        
        if 0 <= row_index < len(self.regras_vr):
            self.regras_vr.pop(row_index)
            self.update_treeview()
            self.master.show_message("Sucesso", "Regra removida e an√°lise atualizada.")
            self.master.regras_vr = self.regras_vr 
            self.master.analisar_dados() 
        else:
             self.master.show_message("Erro", "Erro ao remover regra: √≠ndice inv√°lido.", type="error")

            
    def adicionar_regra_manual(self):
        """Adiciona uma nova regra VR a partir dos campos de entrada."""
        try:
            idade_min_convertida = _converter_idade_input_para_anos(self.idade_min_var.get())
            idade_max_convertida = _converter_idade_input_para_anos(self.idade_max_var.get())

            nova_regra = {
                'exame': self.exame_var.get().upper(),
                'sexo': self.sexo_var.get().upper(),
                'idade_min': idade_min_convertida,
                'idade_max': idade_max_convertida,
                'ref_min': float(self.ref_min_var.get().replace(',', '.')),
                'ref_max': float(self.ref_max_var.get().replace(',', '.')),
            }
            
            if not nova_regra['exame'] or nova_regra['exame'] == "SEM EXAMES":
                 raise ValueError("Selecione ou digite um Exame v√°lido.")
            if nova_regra['ref_min'] >= nova_regra['ref_max']:
                 raise ValueError("Ref Min deve ser menor que Ref Max.")
            if nova_regra['idade_min'] >= nova_regra['idade_max'] and nova_regra['idade_max'] != 0.0:
                 raise ValueError("Idade Min deve ser menor que Idade Max.")
                 
            self.regras_vr.append(nova_regra)
            self.update_treeview()
            self.master.show_message("Sucesso", "Regra adicionada e an√°lise atualizada.")
            self.master.regras_vr = self.regras_vr 
            self.master.analisar_dados() 
            
            self.ref_min_var.set("")
            self.ref_max_var.set("")
            
        except ValueError as e:
            self.master.show_message("Erro de Entrada", f"Erro: {e}. Verifique se os campos num√©ricos est√£o corretos (use ponto para decimal).", type="error")
        except Exception as e:
            self.master.show_message("Erro", f"Erro desconhecido ao adicionar regra: {e}", type="error")


class PeriodSelector(ttk.Toplevel):
    
    def __init__(self, master, datas_disponiveis, callback):
        super().__init__(master)
        self.master = master
        self.datas_disponiveis = datas_disponiveis
        self.callback = callback
        
        self.title("Sele√ß√£o de Per√≠odo Personalizado")
        self.geometry("400x200") 
        self.transient(master) 
        self.grab_set() 
        self.resizable(False, False)
        
        self.data_inicio_var = tk.StringVar(self)
        self.data_fim_var = tk.StringVar(self)
        
        if self.datas_disponiveis:
             self.data_inicio_var.set(self.datas_disponiveis[0])
             self.data_fim_var.set(self.datas_disponiveis[-1])
        else:
             self.data_inicio_var.set("N/A")
             self.data_fim_var.set("N/A")

        self.setup_layout()

    def setup_layout(self):
        main_frame = ttk.Frame(self, padding="15")
        main_frame.pack(fill=BOTH, expand=True)

        ttk.Label(main_frame, text="Selecione o Per√≠odo de An√°lise:", font=("Helvetica Neue", 12, "bold"), bootstyle=PRIMARY).pack(pady=(0, 15))

        frame_inicio = ttk.Frame(main_frame)
        frame_inicio.pack(fill=X, pady=5)
        ttk.Label(frame_inicio, text="Data de In√≠cio:", width=15).pack(side=LEFT)
        combo_inicio = ttk.Combobox(frame_inicio, textvariable=self.data_inicio_var, values=self.datas_disponiveis, state='readonly', bootstyle=INFO)
        combo_inicio.pack(side=RIGHT, fill=X, expand=True)

        frame_fim = ttk.Frame(main_frame)
        frame_fim.pack(fill=X, pady=5)
        ttk.Label(frame_fim, text="Data de Fim:", width=15).pack(side=LEFT)
        combo_fim = ttk.Combobox(frame_fim, textvariable=self.data_fim_var, values=self.datas_disponiveis, state='readonly', bootstyle=INFO)
        combo_fim.pack(side=RIGHT, fill=X, expand=True)

        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill=X, pady=(20, 0))

        ttk.Button(btn_frame, text="Cancelar", command=self.destroy, bootstyle=SECONDARY).pack(side=LEFT, fill=X, expand=True, padx=5)
        ttk.Button(btn_frame, text="Aplicar Filtro", command=self.aplicar_filtro, bootstyle=SUCCESS).pack(side=LEFT, fill=X, expand=True, padx=5)

    def aplicar_filtro(self):
        """Executa o callback com as datas selecionadas e fecha a janela."""
        data_inicio = self.data_inicio_var.get()
        data_fim = self.data_fim_var.get()
        
        if data_inicio == "N/A" or data_fim == "N/A":
             self.master.show_message("Aviso", "Nenhuma data dispon√≠vel para sele√ß√£o.", type="warning")
             self.destroy()
             return

        try:
            # Garante que o formato de leitura √© o DD/MM/AAAA
            inicio_dt = datetime.datetime.strptime(data_inicio, '%d/%m/%Y').date()
            fim_dt = datetime.datetime.strptime(data_fim, '%d/%m/%Y').date()
            
            if inicio_dt > fim_dt:
                self.master.show_message("Erro", "A Data de In√≠cio n√£o pode ser maior que a Data de Fim.", type="error")
                return

            self.callback(data_inicio, data_fim)
            self.destroy()
            
        except ValueError:
            self.master.show_message("Erro", "Ocorreu um erro ao processar as datas. Verifique o formato DD/MM/AAAA.", type="error")
            


class App(ttk.Window):
    def __init__(self):
        super().__init__(themename="flatly") 

        self.title("Sistema de An√°lise Estat√≠stica - Dashboard")
        self.geometry("1400x900") 
        self.minsize(1200, 750) 

        self.df = None
        self.df_analise = None 
        self.regras_vr = [] 
        self.exames_disponiveis = []
        
        self.total_registros = tk.IntVar(value=0)
        # ALTERADO: Mudan√ßa de tk.IntVar para tk.StringVar para exibir o nome do exame
        self.exame_card_display = tk.StringVar(value="Nenhum") 
        self.idade_media = tk.StringVar(value="N/A")
        self.resultado_medio = tk.StringVar(value="N/A")

        self.exame_selecionado = tk.StringVar(self)
        self.exame_selecionado.set("Selecione o Exame") 
        # Garante que o card atualize quando o exame mudar
        self.exame_selecionado.trace_add("write", self.handle_exame_change) 

        self.aba_ativa = tk.StringVar(self, value="An√°lise Geral")
        self.aba_ativa.trace_add("write", self.handle_aba_change) 
        
        # Manter apenas "Completo" para o r√°dio button
        self.periodo_ativo = tk.StringVar(self, value="Completo")
        self.data_inicio = None 
        self.data_fim = None    
        self.datas_disponiveis = [] 
        self.periodo_display = tk.StringVar(self, value="Per√≠odo: Completo") 
        
        self.idade_min_filtro_var = tk.StringVar(self, value="")
        self.idade_max_filtro_var = tk.StringVar(self, value="")
        self.idade_min_filtro = None 
        self.idade_max_filtro = None 
        self.faixa_idade_display = tk.StringVar(self, value="Faixa Et√°ria: Completa")
        
        self.fig = None
        self.ax = None 
        self.canvas = None
        self.canvas_widget = None

        self.setup_dashboard_layout()

    def show_message(self, title, message, type="info"):
        """Exibe uma messagebox customizada."""
        if type == "error":
            tk.messagebox.showerror(title, message, icon='warning') 
        elif type == "warning":
            tk.messagebox.showwarning(title, message, icon='warning')
        else:
            tk.messagebox.showinfo(title, message, icon='info')
            
    def criar_card(self, parent_frame, titulo, valor_var, icone):
        """Cria um card de m√©tricas."""
        card = ttk.Frame(parent_frame, padding="15 10", bootstyle=LIGHT, style='Card.TFrame')
        self.style.configure('Card.TFrame', background='white')
        
        main_content_frame = ttk.Frame(card)
        main_content_frame.pack(fill=BOTH, expand=True)

        ttk.Label(main_content_frame, text=icone, font=("Helvetica Neue", 36), bootstyle=INFO).pack(side=LEFT, padx=(0, 15), pady=0, anchor=CENTER)
        
        data_container_frame = ttk.Frame(main_content_frame)
        data_container_frame.pack(side=LEFT, fill=Y, expand=True)
        
        ttk.Label(data_container_frame, textvariable=valor_var, font=("Helvetica Neue", 28, "bold"), bootstyle=PRIMARY).pack(anchor=W, pady=(0, 0))
        ttk.Label(data_container_frame, text=titulo, font=("Helvetica Neue", 10), bootstyle=SECONDARY).pack(anchor=W, pady=(0, 0))
        
        return card
        
    def atualizar_menus_exame(self):
        """Atualiza o OptionMenu com a lista de exames dispon√≠veis."""
        if not hasattr(self, 'menu_exames'):
            return 
            
        menu = self.menu_exames["menu"]
        menu.delete(0, "end")
        
        menu_items = self.exames_disponiveis if self.exames_disponiveis else ["Selecione o Exame"]

        if self.exame_selecionado.get() not in self.exames_disponiveis:
             self.exame_selecionado.set(menu_items[0])
            
        for exame in menu_items:
            menu.add_command(label=exame, command=tk._setit(self.exame_selecionado, exame))

    def atualizar_cards_metricas(self, df_data):
        """Calcula e atualiza os valores exibidos nos cards."""
        self.total_registros.set(len(df_data))
        
        if df_data.empty:
            # self.tipos_exames.set(0) # Linha antiga
            self.exame_card_display.set("Nenhum") # Novo
            self.idade_media.set("N/A")
            self.resultado_medio.set("N/A")
            return

        # L√≥gica para o card "Exame"
        selected_exame = self.exame_selecionado.get()
        if selected_exame != "Selecione o Exame":
            # Se um exame est√° selecionado (para plotagem), exibe o nome dele
            self.exame_card_display.set(selected_exame)
        else:
            # Se n√£o, exibe a contagem de tipos de exames
            self.exame_card_display.set(f"{df_data['exame'].nunique()} Exames")
        
        idade_med = df_data['idade'].mean()
        self.idade_media.set(f"{idade_med:.0f} anos" if not pd.isna(idade_med) else "N/A")
        
        resultado_med = df_data['resultado'].mean()
        self.resultado_medio.set(f"{resultado_med:.2f}" if not pd.isna(resultado_med) else "N/A")


    def setup_dashboard_layout(self):
        # Frame principal
        main_dashboard_frame = ttk.Frame(self, padding="15", bootstyle=LIGHT)
        main_dashboard_frame.pack(fill=BOTH, expand=True)

        # -----------------------------------------------------
        # 1. Header 
        # -----------------------------------------------------
        header_frame = ttk.Frame(main_dashboard_frame, padding="15 10", bootstyle=LIGHT)
        header_frame.pack(fill=X, pady=(0, 20))
        
        ttk.Label(header_frame, text="Sistema de An√°lise Estat√≠stica", font=("Helvetica Neue", 22, "bold"), bootstyle=PRIMARY).pack(side=LEFT)
        
        action_frame = ttk.Frame(header_frame)
        action_frame.pack(side=RIGHT)
        
        # REMOVIDO: ttk.Button(action_frame, text="Iniciar An√°lise", command=self.analisar_dados, bootstyle=SUCCESS).pack(side=RIGHT, padx=5)
        ttk.Button(action_frame, text="Gerenciar Valores de Refer√™ncia (VR)", command=self.abrir_manager_vr, bootstyle=INFO).pack(side=RIGHT, padx=5)
        

        # -----------------------------------------------------
        # 2. Upload e Status do Arquivo 
        # -----------------------------------------------------
        upload_frame = ttk.Frame(main_dashboard_frame, padding="10", bootstyle=LIGHT, style='Upload.TFrame')
        upload_frame.pack(fill=X, pady=(0, 20))
        self.style.configure('Upload.TFrame', background='white', bordercolor='#dddddd', borderwidth=1)
        
        ttk.Button(upload_frame, text="Upload CSV", command=self.carregar_arquivo, bootstyle=PRIMARY).pack(side=LEFT, padx=(0, 15))
        self.lbl_arquivo = ttk.Label(upload_frame, text="Nenhum arquivo carregado", bootstyle=SECONDARY)
        self.lbl_arquivo.pack(side=LEFT)
        
        # INSTRU√á√ÉO REMOVIDA: Era aqui que ficava "Clique em 'Iniciar An√°lise'"

        # -----------------------------------------------------
        # 3. Cards de M√©tricas 
        # -----------------------------------------------------
        cards_frame = ttk.Frame(main_dashboard_frame, padding="0", bootstyle=LIGHT)
        cards_frame.pack(fill=X, pady=(0, 20))
        
        card_container = ttk.Frame(cards_frame)
        card_container.pack(fill=X, expand=True)
        
        self.criar_card(card_container, "Total de Registros", self.total_registros, "üìà").pack(side=LEFT, fill=X, expand=True, padx=5)
        # ALTERADO: Mudan√ßa do t√≠tulo e da vari√°vel para exibir o nome do exame.
        self.criar_card(card_container, "Exame", self.exame_card_display, "üß™").pack(side=LEFT, fill=X, expand=True, padx=5)
        self.criar_card(card_container, "Idade M√©dia", self.idade_media, "üë§").pack(side=LEFT, fill=X, expand=True, padx=5)
        self.criar_card(card_container, "Resultado M√©dio", self.resultado_medio, "üî¨").pack(side=LEFT, fill=X, expand=True, padx=5)


        # -----------------------------------------------------
        # 4. Filtros de Navega√ß√£o (Abas), Per√≠odo e Idade
        # -----------------------------------------------------
        filter_frame = ttk.Frame(main_dashboard_frame, padding="10", bootstyle=LIGHT, relief=FLAT, borderwidth=1, style='Filter.TFrame')
        filter_frame.pack(fill=X, pady=(0, 15))
        
        self.style.configure('Filter.TFrame', background='white', bordercolor='#dddddd', borderwidth=1)
        
        # --- 4.1. Filtro de Abas ---
        aba_options = ["An√°lise Geral", "Por Sexo", "Por Idade", "Temporal", "Alterados", "Qualidade"]
        tabs_frame = ttk.Frame(filter_frame)
        tabs_frame.pack(side=LEFT)
        
        for i, aba in enumerate(aba_options):
            btn = ttk.Radiobutton(tabs_frame, text=aba, value=aba, variable=self.aba_ativa, 
                                  command=self.atualizar_grafico, bootstyle=(TOOLBUTTON, INFO if aba == "An√°lise Geral" else SECONDARY))
            btn.pack(side=LEFT, padx=3)
        
        ttk.Separator(filter_frame, orient=VERTICAL).pack(side=LEFT, fill=Y, padx=10) 
        
        # --- 4.2. Filtro de Per√≠odo (Apenas Completo e Custom) ---
        period_frame = ttk.Frame(filter_frame, padding=(10, 0)) 
        period_frame.pack(side=LEFT, padx=20, fill=Y)

        # Apenas "Completo" como Radio Button
        period_options = ["Completo"]
        for periodo in period_options:
            btn = ttk.Radiobutton(period_frame, text=periodo, value=periodo, 
                                  variable=self.periodo_ativo, 
                                  command=self.analisar_dados, 
                                  bootstyle=(TOOLBUTTON, SUCCESS))
            btn.pack(side=LEFT, padx=3)
            
        ttk.Button(period_frame, text="Escolher Per√≠odo", 
                   command=self.abrir_seletor_periodo, bootstyle=INFO, width=15).pack(side=LEFT, padx=10)
                   
        ttk.Separator(filter_frame, orient=VERTICAL).pack(side=LEFT, fill=Y, padx=10) 
                   
        # --- 4.3. Filtro de Idade ---
        idade_filter_frame = ttk.Frame(filter_frame)
        idade_filter_frame.pack(side=LEFT, padx=10, fill=Y)

        ttk.Label(idade_filter_frame, text="Faixa Et√°ria (a/d/m):", bootstyle=PRIMARY).pack(side=LEFT, padx=(0, 5))
        
        ttk.Entry(idade_filter_frame, textvariable=self.idade_min_filtro_var, width=5, justify=CENTER).pack(side=LEFT, padx=3)
        ttk.Label(idade_filter_frame, text="at√©").pack(side=LEFT)
        ttk.Entry(idade_filter_frame, textvariable=self.idade_max_filtro_var, width=5, justify=CENTER).pack(side=LEFT, padx=3)
        
        ttk.Button(idade_filter_frame, text="Aplicar", command=self.aplicar_filtro_idade, bootstyle=INFO, width=7).pack(side=LEFT, padx=(10, 3))
        ttk.Button(idade_filter_frame, text="Limpar", command=self.remover_filtro_idade, bootstyle=SECONDARY, width=7).pack(side=LEFT)


        # -----------------------------------------------------
        # 5. Painel de Visualiza√ß√£o (Gr√°fico) 
        # -----------------------------------------------------
        self.chart_container = ttk.Frame(main_dashboard_frame, padding="15", bootstyle=LIGHT, relief=FLAT, borderwidth=1, style='Filter.TFrame')
        self.chart_container.pack(fill=BOTH, expand=True)

        self.chart_title = ttk.Label(self.chart_container, text="Dashboard de An√°lise", font=("Helvetica Neue", 14, "bold"), bootstyle=PRIMARY)
        self.chart_title.pack(anchor=W)
        
        subtitle_frame = ttk.Frame(self.chart_container)
        subtitle_frame.pack(fill=X, pady=(0, 5))

        self.chart_subtitle_periodo = ttk.Label(subtitle_frame, textvariable=self.periodo_display, font=("Helvetica Neue", 10), bootstyle=SECONDARY)
        self.chart_subtitle_periodo.pack(side=LEFT, padx=(0, 15))
        
        self.chart_subtitle_idade = ttk.Label(subtitle_frame, textvariable=self.faixa_idade_display, font=("Helvetica Neue", 10), bootstyle=SECONDARY)
        self.chart_subtitle_idade.pack(side=LEFT)

        self.control_frame = ttk.Frame(self.chart_container)
        self.control_frame.pack(fill=X, pady=(0, 5))
        
        ttk.Label(self.control_frame, text="Exame:", bootstyle=PRIMARY).pack(side=LEFT, padx=5)
        # self.exame_selecionado.trace_add("write", self.atualizar_grafico) # Removido para usar handle_exame_change que chama atualizar_grafico e atualiza cards
        self.menu_exames = ttk.OptionMenu(self.control_frame, self.exame_selecionado, 
                                          "Selecione o Exame", "Selecione o Exame", bootstyle=INFO)
        self.menu_exames.pack(side=LEFT)
        
        # Frame para hospedar o gr√°fico
        self.plot_frame = ttk.Frame(self.chart_container)
        self.plot_frame.pack(fill=BOTH, expand=True)
        
        # Setup inicial do layout (single plot)
        self._setup_plot_area(single_plot=True)

    def _setup_plot_area(self, single_plot=True):
        """
        Prepara a figura, o eixo e o canvas.
        Garante que o canvas anterior seja destru√≠do e um novo criado.
        """
        # 1. Destr√≥i o canvas anterior (widget e refer√™ncia)
        if self.canvas_widget:
            self.canvas_widget.destroy()
            self.canvas_widget = None
            self.canvas = None
            
        # 2. Cria uma nova figura
        self.fig = Figure(figsize=(12, 7), dpi=100)
        
        # 3. Adiciona o subplot/eixo principal se for single-plot
        if single_plot:
            self.ax = self.fig.add_subplot(111)
            # Para manter a compatibilidade com a estrutura anterior
            self.axes = {'ax': self.ax} 
        else:
            # Para multi-plot, os subplots (axes) ser√£o criados dentro das fun√ß√µes de plotagem
            self.ax = None 
            self.axes = {} 
            
        # 4. Cria e empacota o novo canvas
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.plot_frame)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack(fill=BOTH, expand=True)


    def _cleanup_plot_frame(self):
        """Limpa apenas as refer√™ncias internas para garantir que _setup_plot_area recrie o canvas."""
        self.ax = None
        self.axes = {}

    def handle_aba_change(self, *args):
        """Chama a atualiza√ß√£o do gr√°fico quando a aba muda."""
        if not self.df_analise:
            return
        
        self.atualizar_grafico()

    def handle_exame_change(self, *args):
        """Chama a atualiza√ß√£o do gr√°fico E DOS CARDS quando o exame muda."""
        if not self.df_analise:
            return
            
        # Atualiza os cards (para refletir o novo exame selecionado)
        self.atualizar_cards_metricas(self.df_analise)
        # Atualiza o gr√°fico
        self.atualizar_grafico()
        
    def carregar_arquivo(self):
        """Abre a caixa de di√°logo para carregar o arquivo CSV."""
        filepath = filedialog.askopenfilename(
            defaultextension=".csv",
            filetypes=[("Arquivos CSV", "*.csv"), ("Todos os arquivos", "*.*")]
        )
        if not filepath:
            return
            
        try:
            self.df = pd.read_csv(filepath, encoding='utf-8', sep=';', low_memory=False)
            self.lbl_arquivo.config(text=f"Arquivo carregado: {filepath.split('/')[-1]}", bootstyle=SUCCESS)
            self.df.columns = [col.lower().strip() for col in self.df.columns]
            
            # CHAVE: Inicia a an√°lise imediatamente ap√≥s o carregamento
            self.analisar_dados(primeiro_carregamento=True)
            self.show_message("Sucesso", "Dados carregados, pr√©-processados e an√°lise iniciada.")

        except FileNotFoundError:
            self.show_message("Erro", "Arquivo n√£o encontrado.", type="error")
        except Exception as e:
            self.show_message("Erro", f"Erro ao ler arquivo CSV. Verifique o formato (separador ';'). Detalhe: {e}", type="error")

    def abrir_seletor_periodo(self):
        """Abre a janela de sele√ß√£o de per√≠odo personalizado."""
        if not self.datas_disponiveis:
            self.show_message("Aviso", "Nenhum dado carregado para sele√ß√£o de per√≠odo.", type="warning")
            return
            
        PeriodSelector(self, self.datas_disponiveis, self.set_periodo_personalizado)

    def set_periodo_personalizado(self, data_inicio_str, data_fim_str):
        """Define o per√≠odo personalizado e dispara a an√°lise."""
        self.data_inicio = datetime.datetime.strptime(data_inicio_str, '%d/%m/%Y').date()
        self.data_fim = datetime.datetime.strptime(data_fim_str, '%d/%m/%Y').date()
        
        self.periodo_ativo.set(f"Custom: {data_inicio_str} a {data_fim_str}") 
        self.analisar_dados()

    def aplicar_filtro_idade(self):
        """Aplica o filtro de faixa et√°ria inserido pelo usu√°rio."""
        min_str = self.idade_min_filtro_var.get()
        max_str = self.idade_max_filtro_var.get()
        
        try:
            min_val = _converter_idade_input_para_anos(min_str) if min_str else 0.0
            max_val = _converter_idade_input_para_anos(max_str) if max_str else 120.0 # Valor alto padr√£o para 'at√©'

            if min_val >= max_val and max_str: # Se max_str foi preenchido, min deve ser menor que max
                self.show_message("Erro", "Idade M√≠nima deve ser menor que a Idade M√°xima.", type="error")
                return
            
            # Se a idade m√°xima n√£o foi preenchida (max_str vazio), redefina para None para n√£o filtrar pelo 120.0 padr√£o.
            self.idade_min_filtro = min_val if min_str else None
            self.idade_max_filtro = max_val if max_str else None
            
            self.analisar_dados()
            
        except ValueError as e:
            self.show_message("Erro de Idade", str(e), type="error")

    def remover_filtro_idade(self):
        """Remove o filtro de faixa et√°ria."""
        self.idade_min_filtro_var.set("")
        self.idade_max_filtro_var.set("")
        self.idade_min_filtro = None
        self.idade_max_filtro = None
        self.analisar_dados()

    def classificar_resultado(self, row):
        """Classifica o resultado como 'NORMAL', 'ALTO' ou 'BAIXO' com base nas regras VR."""
        exame = row['exame']
        sexo = row['sexo']
        idade = row['idade']
        resultado = row['resultado']

        if pd.isna(resultado) or pd.isna(idade) or pd.isna(sexo):
            return 'N/A'

        regras_aplicaveis = [
            r for r in self.regras_vr 
            if r['exame'] == exame and 
               r['idade_min'] <= idade <= r['idade_max'] and 
               (r['sexo'] == sexo or r['sexo'] == 'AMBOS')
        ]
        
        if not regras_aplicaveis:
            return 'SEM VR'

        regras_sexo = [r for r in regras_aplicaveis if r['sexo'] == sexo]
        regras_ambos = [r for r in regras_aplicaveis if r['sexo'] == 'AMBOS']
        
        # Prioriza regras espec√≠ficas de sexo sobre regras de "AMBOS"
        regras_a_usar = regras_sexo if regras_sexo else regras_ambos
        
        if not regras_a_usar:
            return 'SEM VR' 

        ref_min = min(r['ref_min'] for r in regras_a_usar)
        ref_max = max(r['ref_max'] for r in regras_a_usar)
        
        if ref_min <= resultado <= ref_max:
            return 'NORMAL'
        elif resultado < ref_min:
            return 'BAIXO'
        else:
            return 'ALTO'

    def analisar_dados(self, primeiro_carregamento=False):
        """Pr√©-processa, filtra e analisa os dados brutos."""
        if self.df is None:
            if primeiro_carregamento:
                return
            self.show_message("Aviso", "Nenhum arquivo de dados carregado.", type="warning")
            return

        df_temp = self.df.copy()

        # 1. Pr√©-processamento e Limpeza
        if 'data' in df_temp.columns:
            try:
                # CORRIGIDO: Tentativa prim√°ria usando o formato brasileiro DD/MM/AAAA
                df_temp['data'] = pd.to_datetime(df_temp['data'], format='%d/%m/%Y', errors='coerce').dt.date
            except Exception:
                # Tenta inferir se falhar
                df_temp['data'] = pd.to_datetime(df_temp['data'], errors='coerce').dt.date
            df_temp.dropna(subset=['data'], inplace=True)
            self.datas_disponiveis = sorted([d.strftime('%d/%m/%Y') for d in df_temp['data'].unique()])

        if 'idade' in df_temp.columns:
            df_temp['idade'] = df_temp['idade'].apply(_converter_idade_para_anos)

        if 'resultado' in df_temp.columns:
            df_temp['resultado'] = df_temp['resultado'].astype(str).str.replace(',', '.', regex=False)
            df_temp['resultado'] = pd.to_numeric(df_temp['resultado'], errors='coerce')

        if 'sexo' in df_temp.columns:
            df_temp['sexo'] = df_temp['sexo'].astype(str).str.upper().str.strip().str[0].replace({'M': 'MASCULINO', 'F': 'FEMININO'})
            
        df_temp.dropna(subset=['exame', 'resultado'], inplace=True)
        
        self.exames_disponiveis = sorted(df_temp['exame'].unique().tolist())
        self.atualizar_menus_exame()


        # 2. Aplica√ß√£o de Filtros
        
        # --- 2.1. Filtro de Faixa Et√°ria ---
        if self.idade_min_filtro is not None:
            df_temp = df_temp[df_temp['idade'] >= self.idade_min_filtro]
        if self.idade_max_filtro is not None:
            df_temp = df_temp[df_temp['idade'] <= self.idade_max_filtro]
            
        # Atualiza√ß√£o do display do filtro de idade
        min_disp = _formatar_idade_para_exibicao(self.idade_min_filtro) if self.idade_min_filtro is not None else "0"
        if self.idade_max_filtro is not None:
            max_disp = _formatar_idade_para_exibicao(self.idade_max_filtro)
        elif self.idade_max_filtro_var.get() == "" and self.idade_min_filtro is not None:
            max_disp = "MAX"
        else:
            max_disp = "MAX"

        if self.idade_min_filtro is not None or self.idade_max_filtro is not None:
            self.faixa_idade_display.set(f"Faixa Et√°ria: {min_disp} a {max_disp}")
        else:
            self.faixa_idade_display.set("Faixa Et√°ria: Completa")

        # --- 2.2. Filtro de Per√≠odo ---
        periodo = self.periodo_ativo.get()
        if 'Custom:' in periodo: 
            # Per√≠odo customizado
            data_inicio_filtro = self.data_inicio
            data_fim_filtro = self.data_fim
            periodo_display = f"Per√≠odo: {data_inicio_filtro.strftime('%d/%m/%Y')} a {data_fim_filtro.strftime('%d/%m/%Y')}"
        else:
            # Completo (op√ß√£o padr√£o)
            data_inicio_filtro = df_temp['data'].min() if not df_temp.empty else None
            data_fim_filtro = df_temp['data'].max() if not df_temp.empty else None
            self.data_inicio = data_inicio_filtro
            self.data_fim = data_fim_filtro
            periodo_display = "Per√≠odo: Completo"
            
        self.periodo_display.set(periodo_display)

        if self.data_inicio and self.data_fim and 'data' in df_temp.columns:
            df_temp = df_temp[ 
                (df_temp['data'] >= self.data_inicio) & 
                (df_temp['data'] <= self.data_fim) 
            ]
            
        self.df_analise = df_temp.copy()

        # 3. Classifica√ß√£o VR
        if self.regras_vr and not self.df_analise.empty:
            self.df_analise['status_vr'] = self.df_analise.apply(self.classificar_resultado, axis=1)
        else:
            self.df_analise['status_vr'] = 'SEM VR'
            
        # 4. Atualiza M√©tricas e Gr√°fico
        self.atualizar_cards_metricas(self.df_analise)
        self.atualizar_grafico()


    def atualizar_grafico(self, *args):
        """Plota o gr√°fico apropriado baseado na aba ativa e no exame selecionado."""
        exame = self.exame_selecionado.get()
        aba = self.aba_ativa.get()

        # Atualiza os cards (necess√°rio aqui tamb√©m, pois a sele√ß√£o do exame os afeta)
        if self.df_analise is not None:
            self.atualizar_cards_metricas(self.df_analise)

        if self.df_analise is None or self.df_analise.empty or exame == "Selecione o Exame":
            self._setup_plot_area(single_plot=True)
            self.ax.text(0.5, 0.5, 'Nenhum dado ou exame selecionado para plotagem.', 
                         horizontalalignment='center', verticalalignment='center', 
                         transform=self.ax.transAxes, fontsize=14, color='gray')
            self.ax.set_xticks([])
            self.ax.set_yticks([])
            self.fig.tight_layout()
            self.canvas.draw()
            self.chart_title.config(text="Dashboard de An√°lise")
            return

        df_exame = self.df_analise[self.df_analise['exame'] == exame].copy()
        
        if df_exame.empty:
            self._setup_plot_area(single_plot=True)
            self.ax.text(0.5, 0.5, f'Nenhum registro para o exame "{exame}" ap√≥s a filtragem.', 
                         horizontalalignment='center', verticalalignment='center', 
                         transform=self.ax.transAxes, fontsize=14, color='gray')
            self.ax.set_xticks([])
            self.ax.set_yticks([])
            self.fig.tight_layout()
            self.canvas.draw()
            self.chart_title.config(text="Dados Insuficientes")
            return

        self.chart_title.config(text=f"An√°lise: {exame} - {aba}")
        
        # Executa a plotagem de acordo com a aba (configura o layout antes de plotar)
        if aba in ["An√°lise Geral", "Por Idade", "Temporal", "Qualidade"]:
            # Configura para layout customizado ou single plot, dependendo da aba
            self._setup_plot_area(single_plot=(aba != "Qualidade"))
            
            if aba == "An√°lise Geral":
                self.plot_dotplot_geral(df_exame, exame)
            elif aba == "Por Idade":
                self.plot_histograma_idade(df_exame, exame)
            elif aba == "Temporal":
                self.plot_tendencia_temporal(df_exame, exame)
            elif aba == "Qualidade":
                # Redefinir para garantir que o layout customizado da qualidade seja usado
                self._setup_plot_area(single_plot=False)
                self.plot_qualidade_metrics(df_exame, exame)
                
        elif aba == "Alterados": 
            # USO DE PERSONALIZA√á√ÉO: A aba Alterados usar√° a segmenta√ß√£o Normal vs. Alterado, conforme solicitada pelo usu√°rio.
            self._setup_plot_area(single_plot=False) # Configura para multi-plot
            self.plot_status_multi_bar(df_exame, exame)

        elif aba == "Por Sexo":
            self._setup_plot_area(single_plot=False) # Configura para multi-plot
            self.plot_dotplot_separado_sexo(df_exame, exame)

        self.canvas.draw()


    def abrir_manager_vr(self):
        """Abre a janela de gerenciamento de Valores de Refer√™ncia."""
        if self.df is None:
            self.show_message("Aviso", "Carregue o arquivo CSV primeiro.", type="warning")
            return
        VRManager(self, self.exames_disponiveis, self.regras_vr)

    # --- Fun√ß√µes de Plotagem ---

    def _limpar_grafico(self, ax, title):
        """Fun√ß√£o auxiliar para limpar o eixo e definir o t√≠tulo."""
        ax.clear()
        ax.set_title(title, pad=15)
        ax.tick_params(axis='x', rotation=0)

    def _plot_grouped_bar_chart(self, ax, df_plot, x_col, y_col, hue_col, title, color_map, **kwargs):
        """Plota um gr√°fico de barras agrupadas e adiciona r√≥tulos."""
        self._limpar_grafico(ax, title)
        
        # Garante a ordem e as colunas (importante para 'Alterados')
        if hue_col == 'status_vr':
            categories = ['BAIXO', 'NORMAL', 'ALTO', 'SEM VR', 'N/A']
            df_plot[hue_col] = pd.Categorical(df_plot[hue_col], categories=categories)
            df_plot = df_plot.sort_values(hue_col)
            
        group_counts = df_plot.groupby([x_col, hue_col]).size().unstack(fill_value=0)
        
        # Garante que as colunas 'BAIXO', 'NORMAL', 'ALTO' existam para plotagem na aba 'Alterados'
        if hue_col == 'status_vr':
            for cat in categories:
                if cat not in group_counts.columns:
                    group_counts[cat] = 0

        # Mapeamento para exibir apenas 'Normal' e 'Alterado' na aba 'Alterados'
        if kwargs.get('show_normal_alterado'):
             # Agrupa 'BAIXO' e 'ALTO' em 'Alterado' e filtra 'SEM VR' e 'N/A'
             group_counts['Alterado'] = group_counts['BAIXO'] + group_counts['ALTO']
             group_counts.rename(columns={'NORMAL': 'Normal'}, inplace=True)
             
             # Seleciona apenas as colunas desejadas e remove as categorias detalhadas
             columns_to_show = ['Normal', 'Alterado']
             group_counts = group_counts[[c for c in columns_to_show if c in group_counts.columns]]

             # Recria o color_map para as duas categorias
             color_map = {'Normal': '#0077b6', 'Alterado': '#dc3545'} 
        
        
        group_counts.plot(kind='bar', ax=ax, color=[color_map.get(col, 'gray') for col in group_counts.columns])
        
        ax.set_xlabel(x_col.capitalize())
        ax.set_ylabel(y_col.capitalize() if y_col else "Contagem de Registros")
        
        # Adiciona os r√≥tulos
        for container in ax.containers:
            for bar in container:
                height = bar.get_height()
                if height > 0:
                    ax.annotate(f'{int(height)}',
                                xy=(bar.get_x() + bar.get_width() / 2, height),
                                xytext=(0, 3),  # 3 points vertical offset
                                textcoords="offset points",
                                ha='center', va='bottom', fontsize=8)
        
        ax.legend(title=hue_col.replace('_', ' ').title(), loc='upper right')
        ax.tick_params(axis='x', rotation=0)

        # Adiciona as cores da legenda ao title
        handles, labels = ax.get_legend_handles_labels()
        title_legend = ax.get_legend().get_title().get_text()
        
        # Remove a legenda duplicada do eixo principal
        if kwargs.get('remove_legend', False):
             ax.get_legend().remove()
             
        return handles, labels, title_legend

    # --- Implementa√ß√µes de Plotagem ---

    def plot_dotplot_geral(self, df_exame, exame):
        """Plota o dot plot geral dos resultados, sem segmenta√ß√£o."""
        self._setup_plot_area(single_plot=True)
        self._limpar_grafico(self.ax, f"Distribui√ß√£o Geral dos Resultados de {exame}")

        self.ax.scatter(df_exame['resultado'], [1] * len(df_exame), alpha=0.6, color='#0077b6', s=50)
        self.ax.set_yticks([]) 
        self.ax.set_xlabel("Resultado")
        self.ax.set_ylim(0.5, 1.5)

        # Adicionar tooltips
        if mplcursors:
            mplcursors.cursor(hover=True)

        self.fig.tight_layout()

    def plot_dotplot_separado_sexo(self, df_exame, exame):
        """Plota o dot plot dos resultados segmentado por sexo, e a barra de status VR."""
        df_plot = df_exame.dropna(subset=['sexo', 'resultado']).copy()
        
        # 1. Configura os subplots
        self._cleanup_plot_frame() # Limpa o layout anterior
        gs = gridspec.GridSpec(2, 1, height_ratios=[3, 1], hspace=0.3) 
        ax1 = self.fig.add_subplot(gs[0]) # Dot Plot por Sexo
        ax2 = self.fig.add_subplot(gs[1]) # Bar Chart de Status VR (Geral)
        self.axes = {'ax1': ax1, 'ax2': ax2}
        
        # 2. Dot Plot por Sexo
        self._limpar_grafico(ax1, f"Distribui√ß√£o de Resultados por Sexo para {exame}")
        
        sexos = df_plot['sexo'].unique()
        y_pos = {sexo: i + 1 for i, sexo in enumerate(sorted(sexos))}
        y_labels = sorted(sexos)

        color_map = {'MASCULINO': '#17a2b8', 'FEMININO': '#e83e8c', 'OUTRO': '#ffc107'}
        
        for sexo, df_group in df_plot.groupby('sexo'):
            if sexo in y_pos:
                ax1.scatter(df_group['resultado'], [y_pos[sexo]] * len(df_group), 
                            alpha=0.7, s=50, color=color_map.get(sexo, 'gray'), label=sexo)

        ax1.set_yticks(list(y_pos.values()))
        ax1.set_yticklabels(y_labels)
        ax1.set_xlabel("Resultado")
        ax1.set_ylabel("Sexo")

        if mplcursors:
            mplcursors.cursor(ax1, hover=True)
            
        # 3. Bar Chart de Status VR (Geral)
        
        # Filtrar apenas as categorias que ser√£o mostradas (ignora SEM VR e N/A se houver dados √∫teis)
        status_counts = df_exame['status_vr'].value_counts()
        
        # Prepara√ß√£o para plotagem: Renomear 'BAIXO' e 'ALTO' para 'Alterado'
        plot_data = status_counts.drop(labels=['SEM VR', 'N/A'], errors='ignore')

        normal_count = plot_data.get('NORMAL', 0)
        baixo_count = plot_data.get('BAIXO', 0)
        alto_count = plot_data.get('ALTO', 0)
        alterado_count = baixo_count + alto_count
        
        # DataFrame para plotagem Normal vs. Alterado
        data_to_plot = pd.Series({'Normal': normal_count, 'Alterado': alterado_count})
        
        # Define as cores
        bar_colors = {'Normal': '#0077b6', 'Alterado': '#dc3545'}
        categories_to_plot = data_to_plot.index.tolist()
        
        self._limpar_grafico(ax2, f"Status Geral de VR: Normal vs. Alterado")
        
        bars = ax2.bar(categories_to_plot, data_to_plot.values, 
                       color=[bar_colors[cat] for cat in categories_to_plot])
                       
        ax2.set_ylabel("Contagem")
        ax2.set_xlabel("")
        
        # Adiciona r√≥tulos de contagem
        for bar in bars:
            height = bar.get_height()
            if height > 0:
                 ax2.annotate(f'{int(height)}',
                              xy=(bar.get_x() + bar.get_width() / 2, height),
                              xytext=(0, 3),  # 3 points vertical offset
                              textcoords="offset points",
                              ha='center', va='bottom', fontsize=9)

        self.fig.tight_layout()

    def plot_histograma_idade(self, df_exame, exame):
        """Plota o histograma da idade e o dot plot segmentado por idade em 5 grupos."""
        df_plot = df_exame.dropna(subset=['idade', 'resultado']).copy()
        
        # 1. Configura os subplots
        self._cleanup_plot_frame()
        gs = gridspec.GridSpec(2, 1, height_ratios=[1, 2], hspace=0.4) 
        ax1 = self.fig.add_subplot(gs[0]) # Histograma
        ax2 = self.fig.add_subplot(gs[1]) # Dot Plot por Faixa Et√°ria
        self.axes = {'ax1': ax1, 'ax2': ax2}
        
        # 2. Histograma de Idade
        self._limpar_grafico(ax1, f"Distribui√ß√£o de Idade para {exame}")
        
        # Calcula bins (sqrt(N) ou 20, o que for menor)
        n_bins = int(np.sqrt(len(df_plot))) if len(df_plot) > 0 else 10
        n_bins = min(n_bins, 20)
        
        if n_bins < 5: n_bins = 5 # M√≠nimo de 5 bins
        
        # Plota o histograma
        n, bins, patches = ax1.hist(df_plot['idade'], bins=n_bins, edgecolor='black', color='#17a2b8', alpha=0.7)
        ax1.set_xlabel("Idade (anos)")
        ax1.set_ylabel("Frequ√™ncia")
        
        # 3. Dot Plot por Faixa Et√°ria (5 grupos)
        self._limpar_grafico(ax2, f"Resultados por Faixa Et√°ria para {exame}")
        
        # Cria as faixas et√°rias
        num_groups = 5
        min_age = df_plot['idade'].min()
        max_age = df_plot['idade'].max()
        
        # Define os r√≥tulos de forma mais intelig√≠vel
        if max_age <= 1: # Menos de 1 ano
            bins_age = np.linspace(min_age, max_age, num_groups + 1)
            labels = [f"{round(bins_age[i]*12)}-{round(bins_age[i+1]*12)}m" for i in range(num_groups)]
        elif max_age <= 5: # At√© 5 anos
            bins_age = np.linspace(min_age, max_age, num_groups + 1)
            labels = [f"{round(bins_age[i], 1)}-{round(bins_age[i+1], 1)}a" for i in range(num_groups)]
        else: # Acima de 5 anos
            bins_age = np.linspace(min_age, max_age, num_groups + 1)
            labels = [f"{int(bins_age[i])}-{int(bins_age[i+1])}a" for i in range(num_groups)]


        df_plot['faixa_etaria'] = pd.cut(df_plot['idade'], bins=bins_age, labels=labels, include_lowest=True, right=True)
        
        # Remove grupos com 0 amostras para n√£o plotar
        df_plot = df_plot.dropna(subset=['faixa_etaria'])
        faixas = df_plot['faixa_etaria'].cat.categories.tolist()
        
        y_pos = {faixa: i + 1 for i, faixa in enumerate(faixas)}
        
        for faixa, df_group in df_plot.groupby('faixa_etaria'):
            if faixa in y_pos:
                 ax2.scatter(df_group['resultado'], [y_pos[faixa]] * len(df_group), 
                             alpha=0.7, s=50, color='#0077b6')

        ax2.set_yticks(list(y_pos.values()))
        ax2.set_yticklabels(faixas)
        ax2.set_xlabel("Resultado")
        ax2.set_ylabel("Faixa Et√°ria")
        
        if mplcursors:
            mplcursors.cursor(ax2, hover=True)
            
        self.fig.tight_layout()

    def plot_tendencia_temporal(self, df_exame, exame):
        """Plota a s√©rie temporal da m√©dia m√≥vel dos resultados."""
        
        df_plot = df_exame.dropna(subset=['data', 'resultado']).copy()
        
        if df_plot.empty:
            self._setup_plot_area(single_plot=True)
            self.ax.text(0.5, 0.5, 'Nenhum dado temporal ap√≥s a filtragem.', 
                         horizontalalignment='center', verticalalignment='center', 
                         transform=self.ax.transAxes, fontsize=14, color='gray')
            self.ax.set_xticks([])
            self.ax.set_yticks([])
            self.fig.tight_layout()
            return
            
        self._setup_plot_area(single_plot=True)
        self._limpar_grafico(self.ax, f"Tend√™ncia Temporal dos Resultados (M√©dia M√≥vel 30 dias) - {exame}")

        df_plot['data'] = pd.to_datetime(df_plot['data'])
        df_plot.set_index('data', inplace=True)

        # Agrupa por dia e calcula a m√©dia para preencher datas faltantes na s√©rie
        df_serie = df_plot['resultado'].resample('D').mean().fillna(method='ffill') 
        
        # M√©dia M√≥vel de 30 dias para suavizar a curva
        window_size = 30
        df_media_movel = df_serie.rolling(window=window_size).mean().dropna()

        self.ax.plot(df_media_movel.index, df_media_movel.values, label=f'M√©dia M√≥vel {window_size} dias', color='#0077b6', linewidth=2)
        
        self.ax.set_xlabel("Data")
        self.ax.set_ylabel("Resultado (M√©dia M√≥vel)")

        # Formata√ß√£o do eixo X
        formatter = mdates.DateFormatter('%d/%m/%Y')
        self.ax.xaxis.set_major_formatter(formatter)
        self.ax.tick_params(axis='x', rotation=45)
        
        self.ax.grid(True, linestyle='--', alpha=0.6)
        
        self.fig.tight_layout()

    def plot_status_multi_bar(self, df_exame, exame):
        """Plota os resultados de Normal vs. Alterado (Baixo/Alto) segmentados por Sexo e Idade."""
        df_plot = df_exame.dropna(subset=['status_vr']).copy()
        
        # Configura√ß√£o para 2 gr√°ficos de barras (3:2)
        self._cleanup_plot_frame()
        gs = gridspec.GridSpec(1, 2, width_ratios=[3, 2], wspace=0.3) 
        ax1 = self.fig.add_subplot(gs[0]) # Por Idade
        ax2 = self.fig.add_subplot(gs[1]) # Por Sexo
        self.axes = {'ax1': ax1, 'ax2': ax2}
        
        # Define o mapeamento de cores (Normal/Alterado)
        color_map = {
             'NORMAL': '#0077b6', 
             'BAIXO': '#dc3545', 
             'ALTO': '#dc3545', 
             'SEM VR': 'gray', 
             'N/A': 'lightgray'
        }
        
        # --- 1. Gr√°fico de Barras Agrupadas: POR FAIXA ET√ÅRIA (2 Grupos: 0-18 e >18) ---
        
        df_idade = df_plot.dropna(subset=['idade']).copy()
        df_idade['faixa_idade'] = np.where(df_idade['idade'] <= 18, '0-18 anos', '> 18 anos')

        # 'show_normal_alterado': True ativa o agrupamento de BAIXO/ALTO em 'Alterado' e renomeia 'NORMAL' para 'Normal'
        h1, l1, t1 = self._plot_grouped_bar_chart(
             ax1, df_idade, x_col='faixa_idade', y_col='Contagem', 
             hue_col='status_vr', 
             title=f"Status VR por Faixa Et√°ria ({exame})",
             color_map=color_map, 
             show_normal_alterado=True,
             remove_legend=True # Remove a legenda do eixo para evitar duplicidade
        )
        
        # --- 2. Gr√°fico de Barras Agrupadas: POR SEXO ---
        
        df_sexo = df_plot.dropna(subset=['sexo']).copy()

        # 'show_normal_alterado': True ativa o agrupamento de BAIXO/ALTO em 'Alterado'
        h2, l2, t2 = self._plot_grouped_bar_chart(
             ax2, df_sexo, x_col='sexo', y_col='Contagem', 
             hue_col='status_vr', 
             title=f"Status VR por Sexo ({exame})",
             color_map=color_map,
             show_normal_alterado=True,
             remove_legend=True # Remove a legenda do eixo para evitar duplicidade
        )
        
        # Centraliza a legenda combinada na parte inferior
        self.fig.legend(handles=h1, labels=l1, loc='lower center', ncol=len(l1), title="Status de Valor de Refer√™ncia")
        
        self.fig.tight_layout(rect=[0, 0.05, 1, 1]) # Ajusta para dar espa√ßo √† legenda

    def plot_qualidade_metrics(self, df_exame, exame):
        """
        Plota as m√©tricas de Qualidade (CV e Desvio Padr√£o) e a Tabela de Estat√≠sticas 
        descritivas em um layout de 2x1.
        """
        
        df_plot = df_exame.dropna(subset=['resultado']).copy()
        
        # 1. Configura os subplots
        self._cleanup_plot_frame()
        # Gr√°fico de CV/DP (1/3) e Tabela (2/3)
        gs = gridspec.GridSpec(2, 1, height_ratios=[1, 2], hspace=0.3) 
        ax_stats = self.fig.add_subplot(gs[0]) # Estat√≠sticas/Tabela
        ax_table = self.fig.add_subplot(gs[1]) # Tabela
        self.axes = {'ax_stats': ax_stats, 'ax_table': ax_table}
        
        # O ax_table ser√° usado para desenhar o Matplotlib Table
        ax_table.axis('off')
        
        # --- 1. Estat√≠sticas Chave (DP e CV) ---
        self._limpar_grafico(ax_stats, f"M√©tricas de Qualidade: Desvio Padr√£o e CV - {exame}")

        mean = df_plot['resultado'].mean()
        std = df_plot['resultado'].std()
        cv = (std / mean) * 100 if mean != 0 else 0
        
        metrics = {'Desvio Padr√£o': std, 'Coef. Varia√ß√£o (%)': cv}
        metric_names = list(metrics.keys())
        metric_values = list(metrics.values())

        bars = ax_stats.bar(metric_names, metric_values, color=['#0077b6', '#dc3545'], alpha=0.8)
        
        ax_stats.set_ylabel("Valor")
        
        # Adiciona r√≥tulos de contagem
        for bar in bars:
            height = bar.get_height()
            if height > 0:
                 ax_stats.annotate(f'{height:.2f}',
                              xy=(bar.get_x() + bar.get_width() / 2, height),
                              xytext=(0, 3),  # 3 points vertical offset
                              textcoords="offset points",
                              ha='center', va='bottom', fontsize=10, weight='bold')

        ax_stats.tick_params(axis='x', rotation=0)
        
        # --- 2. Tabela de Estat√≠sticas Descritivas ---

        desc_stats = df_plot['resultado'].describe().to_frame().reset_index()
        desc_stats.columns = ['M√©trica', 'Valor']
        
        # Adiciona o CV na tabela descritiva (para n√£o aparecer duplicado no gr√°fico)
        cv_row = pd.DataFrame([{'M√©trica': 'cv', 'Valor': cv}])
        
        df_table = pd.concat([desc_stats, cv_row], ignore_index=True)
        
        df_table.rename(columns={'M√©trica': 'Estat√≠stica'}, inplace=True)
        
        # Mapeamento para nomes em portugu√™s
        pt_names = {
            'count': 'N Amostras', 'mean': 'M√©dia (xÃÑ)', 'std': 'Desvio Padr√£o', 
            'min': 'M√≠nimo', '25%': 'Q1', '50%': 'Mediana (Q2)', '75%': 'Q3', 'max': 'M√°ximo',
            'cv': 'Coef. Varia√ß√£o (%)'
        }
        df_table['Estat√≠stica'] = df_table['Estat√≠stica'].replace(pt_names)
        
        # Formata os valores num√©ricos (exceto N Amostras)
        df_table['Valor'] = df_table.apply(
            lambda row: f"{row['Valor']:.2f}" if row['Estat√≠stica'] != 'N Amostras' else int(row['Valor']), 
            axis=1
        )
        
        # Desenha a tabela usando o Matplotlib Table
        table = ax_table.table(cellText=df_table.values, 
                               colLabels=df_table.columns, 
                               loc='center', 
                               cellLoc='center',
                               colColours=["#0077b6", "#0077b6"], 
                               colWidths=[0.4, 0.4])
        
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1.2, 1.2)
        
        # Estilo dos cabe√ßalhos
        for (i, j), cell in table.get_celld().items():
            if i == 0:
                cell.set_text_props(weight='bold', color='white')
                cell.set_facecolor('#0077b6') 
            elif df_table.iloc[i-1]['Estat√≠stica'] == 'Coef. Varia√ß√£o (%)':
                 cell.set_facecolor('#f8d7da') # Cor de destaque para o CV
                 cell.set_text_props(weight='bold', color='#721c24')


        self.fig.tight_layout()


if __name__ == "__main__":
    app = App()
    app.mainloop()
